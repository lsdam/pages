<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
          name="viewport">
    <meta content="ie=edge" http-equiv="X-UA-Compatible">
    <title>Document</title>
    <link href="index.css" rel="stylesheet">
</head>
<body>

<canvas id="fixed-canvas"></canvas>
<canvas id="canvas"></canvas>

<script>
    const canvas = Array.from(document.querySelectorAll('canvas'))
    const context = canvas.map(el => el.getContext('2d'))

    const [fixedCanvas, activeCanvas] = canvas
    const [fixedContext, movableContext] = context

    const TYPE_RECT = 'TYPE_RECT'
    const TYPE_CIRCLE = 'TYPE_CIRCLE'

    const SIZE_RECT = 88
    const SIZE_CIRCLE = 100

    const COLOR_FIXED_FIGURE = '#cecece'
    const COLOR_FIGURE = 'orange'

    const FIXED_FIGURE_LIST = [
        {
            type: TYPE_RECT,
            x: 99,
            y: 276,
            size: SIZE_RECT,
            color: COLOR_FIXED_FIGURE,
            isFixed: true,
        },
        {
            type: TYPE_RECT,
            x: 44,
            y: 420,
            x: 99,
            y: 276,
            size: SIZE_RECT,
            color: COLOR_FIGURE,
            isFixed: true,
        },
        // {
        //     type: TYPE_CIRCLE,
        //     x: 212,
        //     y: 320,
        //     size: SIZE_CIRCLE,
        //     color: COLOR_FIXED_FIGURE,
        //     isFixed: true,
        //     composite: 'xor',
        // },
        {
            type: TYPE_CIRCLE,
            x: 212,
            y: 320,
            size: SIZE_CIRCLE,
            color: COLOR_FIXED_FIGURE,
            isFixed: true,
            composite: 'xor',
        },
        // {
        //     type: TYPE_CIRCLE,
        //     x: 280,
        //     y: 140,
        //     size: SIZE_CIRCLE,
        //     color: COLOR_FIGURE,
        //     isFixed: true,
        // },
    ]

    const FIGURE_LIST = [
        {
            type: TYPE_RECT,
            x: 99,
            y: 276,
            size: SIZE_RECT,
            color: 'orange',
            // color: '#cecece',
            isSelected: false,
        },
        {
            type: TYPE_CIRCLE,
            x: 212,
            y: 320,
            size: SIZE_CIRCLE,
            color: 'blue',
            isSelected: false,
            composite: 'xor',
        },
        // {
        //     type: TYPE_CIRCLE,
        //     x: 280,
        //     y: 140,
        //     x: 212,
        //     y: 320,
        //     size: SIZE_CIRCLE,
        //     color: 'red',
        //     isSelected: false,
        //     composite: 'destination-atop',
        // },
    ]

    let previousSelectedFigure
    let isDragging = false

    startup()

    function startup() {
        resizeCanvas()

        activeCanvas.addEventListener("touchstart", handleStart, false)
        activeCanvas.addEventListener("touchend", stopDragging, false)
        activeCanvas.addEventListener("touchcancel", stopDragging, false)
        activeCanvas.addEventListener("touchmove", handleMove, false)
    }

    // resize the canvas to fill browser window dynamically
    window.addEventListener('resize', resizeCanvas, false);

    function resizeCanvas() {
        canvas.forEach(el => {
            el.width = window.innerWidth
            el.height = window.innerHeight
        })

        initCanvas()

        FIXED_FIGURE_LIST.forEach(figure => {
            switch (figure.type) {
                case TYPE_RECT:
                    drawRect(figure)
                    break
                case TYPE_CIRCLE:
                    drawCircle(figure)
                    break
            }
        })

        FIGURE_LIST.forEach(figure => {
            switch (figure.type) {
                case TYPE_RECT:
                    drawRect(figure)
                    break
                case TYPE_CIRCLE:
                    drawCircle(figure)
                    break
            }
        })
    }

    function initCanvas() {
        // context.forEach(el => {
        //     el.clearRect(0, 0, fixedCanvas.width, fixedCanvas.height)
        // })
        movableContext.clearRect(0, 0, fixedCanvas.width, fixedCanvas.height)

        // FIXED_FIGURE_LIST.forEach(figure => {
        //     switch (figure.type) {
        //         case TYPE_RECT:
        //             drawRect(figure)
        //             break
        //         case TYPE_CIRCLE:
        //             drawCircle(figure)
        //             break
        //     }
        // })
    }

    function stopDragging() {
        isDragging = false
    }

    function isRect(figure, startX, startY) {
        const {x, y, size} = figure

        return startX > x && startX < (x + size) && startY > y && startY < (y + size)
    }

    function isCircle(figure, startX, startY) {
        const {x, y, size} = figure

        let distanceFromCenter = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2))

        return distanceFromCenter <= (size / 2)
    }

    function changeFigureStatus(figure) {
        if (previousSelectedFigure != null) previousSelectedFigure.isSelected = false

        previousSelectedFigure = figure

        figure.isSelected = true

        isDragging = true
    }

    function handleStart(e) {
        e = e.changedTouches[0]

        let startX = e.pageX - activeCanvas.offsetLeft
        let startY = e.pageY - activeCanvas.offsetTop

        initCanvas()

        FIGURE_LIST
            .forEach(figure => {
                switch (figure.type) {
                    case TYPE_RECT:
                        if (isRect(figure, startX, startY)) changeFigureStatus(figure)

                        drawRect(figure)

                        break
                    case TYPE_CIRCLE:
                        if (isCircle(figure, startX, startY)) changeFigureStatus(figure)

                        drawCircle(figure)

                        break
                }
            })
    }

    function handleMove(e) {
        if (!isDragging || !previousSelectedFigure) return

        e = e.changedTouches[0]

        let x, y;

        initCanvas()

        const {type} = previousSelectedFigure

        FIGURE_LIST
            .forEach(figure => {
                switch (figure.type) {
                    case TYPE_RECT:

                        x = e.pageX - activeCanvas.offsetLeft - (figure.size / 2)
                        y = e.pageY - activeCanvas.offsetTop - (figure.size / 2)

                        if (x < 0) x = 0
                        if (y < 0) y = 0
                        if (x > activeCanvas.width - previousSelectedFigure.size) x = activeCanvas.width - previousSelectedFigure.size
                        if (y > activeCanvas.height - previousSelectedFigure.size) y = activeCanvas.height - previousSelectedFigure.size

                        if (type === TYPE_RECT) {
                            previousSelectedFigure.x = x
                            previousSelectedFigure.y = y
                        }

                        drawRect(figure)

                        break
                    case TYPE_CIRCLE:

                        x = e.pageX - activeCanvas.offsetLeft
                        y = e.pageY - activeCanvas.offsetTop

                        if (x < previousSelectedFigure.size / 2) x = previousSelectedFigure.size / 2
                        if (y < previousSelectedFigure.size / 2) y = previousSelectedFigure.size / 2
                        if (x > activeCanvas.width - previousSelectedFigure.size / 2) x = activeCanvas.width - previousSelectedFigure.size / 2
                        if (y > activeCanvas.height - previousSelectedFigure.size / 2) y = activeCanvas.height - previousSelectedFigure.size / 2

                        if (type === TYPE_CIRCLE) {
                            previousSelectedFigure.x = x
                            previousSelectedFigure.y = y
                        }

                        drawCircle(figure)

                        break
                }
            })
    }

    function drawRect(figure) {
        const {x, y, size, color} = figure

        const ctx = figure.isFixed ? fixedContext : movableContext

        ctx.beginPath()
        ctx.rect(x, y, size, size)
        ctx.fillStyle = color
        ctx.globalCompositeOperation = figure.composite ?? 'source-over'
        ctx.fill()
    }

    function drawCircle(figure) {
        const {x, y, size, color} = figure

        const ctx = figure.isFixed ? fixedContext : movableContext

        ctx.beginPath()
        ctx.arc(x, y, size / 2, 0, 2 * Math.PI)
        ctx.fillStyle = color
        ctx.globalCompositeOperation = figure.composite ?? 'source-over'
        ctx.fill()
    }
</script>

</body>
</html>